<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\Screen.js - DreamJs</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="DreamJs"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.8</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\Screen.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * @constructor
 *&#x2F;
dream.Screen = function(canvas, minWidth, minHeight, maxWidth, maxHeight, scaleMode){
	var screen = this;
	
	this.scaleMode = dream.Screen.ScaleMode.SHOW_ALL;
	if(scaleMode != undefined) this.scaleMode = scaleMode;

	this.fc = 0;
	this._frameRate = 0;
	this.frameRate = this._frameRate;
	
	this.canvas = canvas;
	this.context = this.canvas.getContext(&quot;2d&quot;);
	
	this.minWidth = minWidth || this.canvas.width;
	this.minHeight = minHeight || this.canvas.height;
	this.maxWidth = maxWidth || this.minWidth;
	this.maxHeight = maxHeight || this.minHeight;

	this.width = this.canvas.width;
	this.height = this.canvas.height;
	
	this.rect = new dream.Rect(0, 0, this.width, this.height, new dream.transform.Scale);
	
	this.redrawRegions = new dream.util.RedrawRegionList();
	this.rerenderBuffer = new dream.util.BufferCanvas(0, 0);
	
	this.input = new dream.input.InputHandler(this);
	this.scenes = new dream.collection.Selector;

	this.scenes.onSelect.add(function(scene){
		scene.screenBoundary.width = screen.width;
		scene.screenBoundary.height = screen.height;
		screen.hovered = null;
		
		screen.redrawRegions.add(new dream.Rect(0,0, screen.width, screen.height));
		scene.onBoundaryChange.add(function(oldRect){
			screen.redrawRegions.add(new dream.Rect(0, 0, this.viewport.width, this.viewport.height));
		}, screen);
		
		scene.onImageChange.add(function(rects){
			screen.redrawRegions.addArray(rects&#x2F;*.map(function(r){return r.clone();})*&#x2F;);
		}, screen);

		scene.prepare(function(){
			screen.render(scene);
		});
		
		dream.event.dispatch(scene, &quot;onResize&quot;);
	});
	
	this.scenes.onDeselect.add(function(scene){
		scene.onBoundaryChange.removeByOwner(screen);
		scene.onImageChange.removeByOwner(screen);
		scene.screenBoundary.width = 0;
		scene.screenBoundary.height = 0;
		dream.event.dispatch(scene, &quot;onResize&quot;);
		prevScene = scene
	});
	
	this.updateSize();
	
	window.addEventListener(&quot;resize&quot;, function(){
		screen.updateSize();
	},false);

	window.addEventListener(&quot;orientationchange &quot;, function(){
		screen.updateSize();
	},false);
		
}.inherits(dream.VisualAsset);

dream.event.create(dream.VisualAsset.prototype, &quot;onResize&quot;);

dream.Screen.prototype.pause = function(){
	var craf = this.cancelRequestAnimationFrameFunction;
	craf(this._AFID);
	this.isdrawing = false;
};

dream.Screen.prototype.resume = function(){
	this.render();
};

dream.Screen.prototype.render = function(){		
	this.fc++;
	dream.fc ++;
	
	var checkInput = this.fc % this.input.interval == 0;
	
	if(checkInput){
		var kbs;
		for(var k in this.input.downKeys){
			if(kbs = this.keyBindings.index.key[k])
				for(var i=0, kb; kb = kbs[i]; i++)
					kb.fn(this.input.downKeys[k]);
			this.input.downKeys[k]++;
		}
	}
	
	this.paint(this.context, new dream.Point, new dream.Rect(0,0, this.width, this.height));
	
	if(checkInput){
		this.checkHover(new dream.input.MouseEvent(null, this.input.mouse.position, this));
		if(this.input.mouse.isDown) this.raiseDrag(new dream.input.MouseEvent(null, this.input.mouse.position, this));
	}
	
	if(!this.isdrawing){
		this.isdrawing = true;
		var screen = this, raf = this.requestAnimationFrameFunction; 
		this._AFID = raf(function(){screen.isdrawing = false;screen.render();});
	}
};

dream.Screen.prototype.paintWithoutRedrawRegion = function(ctx, rect, renderRect) {
	var scene = this.scenes.current;
	scene.step();
	ctx.clearRect(0,0,renderRect.width, renderRect.height);
	scene.render(ctx, new dream.Point, renderRect);
};

dream.Screen.prototype.paintWithClippingRedrawRegion = function(ctx, origin, renderRect) {
	var rgCount = 0;
	var scene = this.scenes.current;
	scene.step();
	var rg;
	for(var i = 0, ll = this.redrawRegions.length; i &lt; ll; i++){
		var rr = this.redrawRegions[i];
		if(rg = rr.getIntersectWith(renderRect)){
			var l = (rg.left | 0) - 1, t = (rg.top | 0) - 1, w = (rg.width | 0) + 2 , h = (rg.height | 0) + 2;
			ctx.save();
			ctx.beginPath();
			ctx.rect(l, t, w, h);
			ctx.clip();
			ctx.closePath();
			rgCount++;
			ctx.clearRect(l, t, w, h);
			scene.render(ctx, origin, new dream.Rect(l, t, w, h));
			ctx.restore();
			&#x2F;&#x2F;console.log(rr+&quot;&quot;);
		}
	}
	this.redrawRegions.clear();
	&#x2F;&#x2F;if(rgCount) console.log(rgCount +&quot; rerender regions.&quot; );
};

dream.Screen.prototype.paintWithBufferdRedrawRegion = function(ctx, rect, renderRect) {
	var rgCount = 0;
	
	var scene = this.scenes.current;
	scene.step();
		
	var rg;
	for(var i = 0, l = this.redrawRegions.length; i &lt; l; i++){
		if(rg = rr.getIntersectWith(renderRect)){
			var rb = this.rerenderBuffer;
			rb.canvas.width = rg.width;
			rb.canvas.height = rg.height;
			rgCount++;
			ctx.clearRect(rg.left, rg.top, rg.width, rg.height);
			scene.render(rb.context, new dream.Point(-rg.left, -rg.top), rg);
			ctx.drawImage(rb.canvas, 0, 0, rg.width, rg.height, rg.left, rg.top, rg.width, rg.height);
			&#x2F;&#x2F;console.log(rr+&quot;&quot;);
		}
	}
	this.redrawRegions.clear();
	&#x2F;&#x2F;if(rgCount) console.log(rgCount +&quot; rerender regions.&quot; );
};

dream.Screen.prototype.paint = dream.Screen.prototype.paintWithClippingRedrawRegion;
&#x2F;&#x2F;dream.Screen.prototype.paint = dream.Screen.prototype.paintWithBufferdRedrawRegion;
&#x2F;&#x2F;dream.Screen.prototype.paint = dream.Screen.prototype.paintWithoutRedrawRegion;

dream.Screen.prototype.checkHover = function (event){
	if( this.isHovered ){
		if(!this.hovered){
			this.hovered = this.scenes.current;
			dream.event.dispatch(this, &quot;onMouseEnter&quot;, event);
		}
		this.hovered.checkHover(event.toLocal(this.hovered));
	}
};

dream.Screen.prototype.updateSize = function() {
	var ow = this.canvas.offsetWidth;
	var oh = this.canvas.offsetHeight;
	
	if(ow &lt; this.minWidth)
		this.width = this.minWidth;
	else if (ow &gt; this.maxWidth)
		this.width = this.maxWidth;
	else
		this.width = ow;
	
	if(oh &lt; this.minHeight)
		this.height = this.minHeight;
	else if (oh &gt; this.maxHeight)
		this.height = this.maxHeight;
	else
		this.height = oh;
	
	
	this.scaleX = this.canvas.offsetWidth &#x2F; this.width;
	this.scaleY = this.canvas.offsetHeight &#x2F; this.height;
	
	if(this.scaleMode &amp;&amp; this.scaleX != this.scaleY){
		if(this.scaleMode == dream.Screen.ScaleMode.SHOW_ALL){
			if(this.scaleX &lt; this.scaleY){
				this.height = this.canvas.offsetHeight &#x2F; this.scaleX; 
			}else{
				this.width = this.canvas.offsetWidth &#x2F; this.scaleY;
			}
		}else{
			if(this.scaleX &gt; this.scaleY){
				this.height = this.canvas.offsetHeight &#x2F; this.scaleX; 
			}else{
				this.width = this.canvas.offsetWidth &#x2F; this.scaleY;
			}
		}
		
		this.scaleX = this.canvas.offsetWidth &#x2F; this.width;
		this.scaleY = this.canvas.offsetHeight &#x2F; this.height;
	}
	
	this.canvas.width = this.rect.width = this.width = this.width | 0;
	this.canvas.height = this.rect.height = this.height = this.height | 0;
	
	this.rect.transformation.x = this.scaleX;
	this.rect.transformation.y = this.scaleY;
	
	if(this.scenes.current){
		this.scenes.current.screenBoundary.width = this.width;
		this.scenes.current.screenBoundary.height = this.height;
		dream.event.dispatch(this.scenes.current, &quot;onResize&quot;);
	}
	
	this.redrawRegions.add(new dream.Rect(0,0, screen.width, screen.height));

	dream.event.dispatch(this, &quot;onResize&quot;);
};

dream.Screen.prototype.highlight = function(rect) {
	this.context.strokeStyle = &quot;#f00&quot;;this.context.strokeRect(rect.left, rect.top, rect.width, rect.height);
};

Object.defineProperty(dream.Screen.prototype, &quot;frameRate&quot;, {
	get : function() {
		return this._frameRate;
	},
	set : function(v) {
		this.requestAnimationFrameFunction = dream.util.getRequestAnimationFrame(v);
		this.cancelRequestAnimationFrameFunction = dream.util.getCancelRequestAnimationFrame(v);
		this._frameRate = v;
	}
});

dream.Screen.ScaleMode = {
	EXACT_FIT: 0,
	SHOW_ALL: 1,
	NO_BORDER: 2
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
